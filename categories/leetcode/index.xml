<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>leetcode on 风落云起</title>
    <link>https://betterfor.github.io/categories/leetcode/</link>
    <description>Recent content in leetcode on 风落云起</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh</language>
    <copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright>
    <lastBuildDate>Sat, 06 Feb 2021 21:20:19 +0800</lastBuildDate><atom:link href="https://betterfor.github.io/categories/leetcode/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>LEETCODE 005. 最长回文串</title>
      <link>https://betterfor.github.io/2021/02/005/</link>
      <pubDate>Sat, 06 Feb 2021 21:20:19 +0800</pubDate>
      
      <guid>https://betterfor.github.io/2021/02/005/</guid>
      <description>力扣百题系列
 大家好，我是小耗。
今天给大家带来的是经典题之回文串。
什么是回文串？正着读和反着读都是一样的字符串就是回文串，例如level。
题目 给一个字符串s，找出s中最长的回文子串。
题解 1、暴力法
判断一个字符串是否是回文串，然后再找出所有的回文子串。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  func longestPalindrome(s string) string { var maxLen int var maxStr string for i := 0; i &amp;lt; len(s); i++ { for j := i + 1; j &amp;lt; len(s)+1; j++ { len := isPalindrome(s[i:j]) if len &amp;gt; maxLen { maxStr = s[i:j] maxLen = len } } } return maxStr } func isPalindrome(s string) int { var newStr string for i := len(s)-1; i &amp;gt;= 0; i--{ newStr += s[i:i+1] } if s == newStr { return len(s) } return 0 }   时间复杂度O(n^3^)，空间复杂度O(1)。</description>
    </item>
    
    <item>
      <title>LEETCODE 1423. 可获得的最大点数</title>
      <link>https://betterfor.github.io/2021/02/1423/</link>
      <pubDate>Sat, 06 Feb 2021 20:52:42 +0800</pubDate>
      
      <guid>https://betterfor.github.io/2021/02/1423/</guid>
      <description>大家好，我是沉迷于刷题的小耗。
今天给大家带来的是力扣1423题：可获得的最大点数
题目 几张卡牌排成一行，每张卡牌都有一个点数。点数由整数数组cardPoints给出。
每次行动，你可以从行的开头或结尾拿一张卡牌，最终你必须正好拿k张卡牌。
你的点数就是你拿到手中所有卡牌点数之和。
给你一个整数数组cardPoints和整数k，请你返回可以获得的最大点数。
示例 **输入：**cardPoints = [1,2,3,4,5,6,1], k = 3 **输出：**12 **解释：**第一次行动，不管拿哪张牌，你的点数总是 1 。但是，先拿最右边的卡牌将会最大化你的可获得点数。最优策略是拿右边的三张牌，最终点数为 1 + 6 + 5 = 12 。
题解 滑动窗口 如果从左边拿走i个，那么从右边会拿走k-i个，这样i从0到k的最大值就是所求的最大点数。
i=0时，左0，右k。
i=1时，左1，右k-1。
你会发现，有部分值会重复累加，那么我们先把这部分重复累加的值先求出来。
left是从左向右的累加序列，right是从右向左的累加序列。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  func maxScore(cardPoints []int, k int) (ans int) { n := len(cardPoints) var left, right = make([]int, k), make([]int, k) left[0], right[0] = cardPoints[0], cardPoints[n-1] for i := 1; i &amp;lt; k; i++ { left[i] = left[i-1] + cardPoints[i] right[i] = right[i-1] + cardPoints[n-i-1] } left, right = append([]int{0}, left.</description>
    </item>
    
    <item>
      <title>LEETCODE 004. 寻找两个正序数组的中位数</title>
      <link>https://betterfor.github.io/2021/02/004/</link>
      <pubDate>Fri, 05 Feb 2021 20:05:03 +0800</pubDate>
      
      <guid>https://betterfor.github.io/2021/02/004/</guid>
      <description>力扣百题系列
 今天给大家带来一道关于数组的难题。
题目 给定两个大小为m和n的正序（从小到大）数组nums1和nums2。返回这两个正序数组合并后的中位数。
暴力法 将两个正序数组合并成一个正序数组，然后再求中位数，似乎是一个方法。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37  func findMedianSortedArrays(nums1 []int, nums2 []int) float64 { n1,n2 := len(nums1),len(nums2) nums := make([]int,n1+n2) // 将两个数组合并 	var idx,i,j int for idx &amp;lt; n1+n2 { if i == n1 { for j &amp;lt; n2 { nums[idx] = nums2[j] j++ idx++ } break } if j == n2 { for i &amp;lt; n1 { nums[idx] =nums1[i] i++ idx++ } break } if nums1[i] &amp;lt; nums2[j] { nums[idx] = nums1[i] i++ } else { nums[idx] = nums2[j] j++ } idx++ } if cnt := n1 + n2; cnt%2 == 0 { return float64(nums[cnt/2-1]+nums[cnt/2])/2.</description>
    </item>
    
    <item>
      <title>LEETCODE 1208. 尽可能使字符串相等</title>
      <link>https://betterfor.github.io/2021/02/1208/</link>
      <pubDate>Fri, 05 Feb 2021 20:04:57 +0800</pubDate>
      
      <guid>https://betterfor.github.io/2021/02/1208/</guid>
      <description>大家好，我是沉迷于刷题的小耗。
今天给大家带来的是力扣1208题：尽可能使字符串相等
题目 给你两个长度相同的字符串，s和t。
将s中的第i个字符变到t中的第i个字符需要|s[i]-t[i]|的开销(开销可能为0)，也就是两个字符的ASCII码值的差的绝对值。
用于变更字符串的最大预算是maxCount。在转化字符串时，总开销应当小于等于该预算，这也意味着字符串转化可能是不完全的。
如果你可以将s的子字符串转化为它在t中对应的子字符串，则返回可以转化的最大长度。
示例 输入：s = &amp;ldquo;abcd&amp;rdquo;, t = &amp;ldquo;bcdf&amp;rdquo;, cost = 3 输出：3 解释：s 中的 &amp;ldquo;abc&amp;rdquo; 可以变为 &amp;ldquo;bcd&amp;rdquo;。开销为 3，所以最大长度为 3。
题解 先理解一下题意，s和t是在相同位置上的字符进行比较，|s[i]-t[i]|为一位上的开销，那么我们可以得到每一位的开销。而要从s和t找到一个子串，使得子串的开销之和小于最大开销，并使得子串的长度最长。
二分法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  func equalSubstring(s string, t string, maxCost int) (ans int) { n := len(s) diff := make([]int,n+1) // 递增序列 	for i, ch := range s { diff[i+1] = diff[i]+abs(int(ch)-int(t[i])) } for i := 1; i &amp;lt;= n; i++ { start := sort.</description>
    </item>
    
    <item>
      <title>LEETCODE 003. 无重复字符的最长子串</title>
      <link>https://betterfor.github.io/2021/02/003/</link>
      <pubDate>Thu, 04 Feb 2021 21:02:28 +0800</pubDate>
      
      <guid>https://betterfor.github.io/2021/02/003/</guid>
      <description>力扣百题系列
 众所周知啊，字符串是力扣题比较大的一个分类。今天我们就来解决第一道字符串题。
题目 给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。
先来考虑一下这道题要我们干什么？
首先抓住几个关键字：重复字符，最长子串。
首先子串是包括英文字母，数字，符号和空格组成的，在一个字符串中找一个小子串，这是不是符合滑动窗口的概念？
用一个例子来展示一下。
字符串abcabcbb,列举出最长子串
 以(a)bcabcbb开始的最长子串为(abc)abcbb 以a(b)cabcbb开始的最长子串为a(bca)bcbb 以ab(c)abcbb开始的最长子串为ab(cab)cbb 以abc(a)bcbb开始的最长子串为abc(abc)bb 以abca(b)cbb开始的最长子串为abca(bc)bb 以abcab(c)bb开始的最长子串为abcab(cb)b 以abcabc(b)b开始的最长子串为abcabc(b)b 以abcabcb(b)开始的最长子串为abcabcb(b)  我们发现依次递增起始子串的位置，那么子串结束位置也是递增的。这是因为我们以字符串中的第k个字符作为起点，并且得到不包含重复子串的结束位置显然大于k。这样我们可以使用双指针法解决这个问题。
双指针法 1、暴力法
按照常规的做法是固定左指针，然后从左指针位置开始向右遍历，找到重复字符为止；然后再向右移动左指针。当然，我们会发现一些重复的字符会被不断访问。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  func lengthOfLongestSubstring(s string) int { var maxLen int for i := 0; i &amp;lt; len(s); i++ { for j := i + 1; j &amp;lt;= len(s); j++ { if isUnique(s[i:j]) { if len(s[i:j]) &amp;gt; maxLen { maxLen = len(s[i:j]) } } else { // 如果该子串重复，继续添加后续字符也还是不重复  break } } } return maxLen } func isUnique(s string) bool { var m = make(map[int32]bool) for _, vChar := range s { if _, ok := m[vChar]; ok { return false } m[vChar] = true } return true }   时间复杂度O(n^3^),空间复杂度O(min(n,m)),我们需要 O(k) 的空间来检查子字符串中是否有重复字符，其中 k 表示 Set 的大小。而 Set 的大小取决于字符串 n 的大小以及字符集/字母 m 的大小。</description>
    </item>
    
    <item>
      <title>LEETCODE 643. 子数组最大平均数I</title>
      <link>https://betterfor.github.io/2021/02/643/</link>
      <pubDate>Thu, 04 Feb 2021 20:47:52 +0800</pubDate>
      
      <guid>https://betterfor.github.io/2021/02/643/</guid>
      <description>大家好，我是沉迷于刷题的小耗。
今天给大家带来的是力扣643题：子数组最大平均数I
题目 给出n个整数，找出平均数最大且长度为k的连续子数组，并输出该最大平均数。
示例 输入：[1,12,-5,-6,50,3], k = 4 **输出：**12.75 **解释：**最大平均数 (12-5-6+50)/4 = 51/4 = 12.75
题解 先停顿个10秒，考虑一下这道题要考我们什么？
是连续数组的最值，也就是滑动窗口的和。
而遇到滑动窗口的题，我们通常用双指针来表示滑动窗口的左右。
这道题比较简单，只是来求和。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  func findMaxAverage(nums []int, k int) float64 { var sum int for _,num := range nums[:k] { sum += num } ans := sum for i := k; i &amp;lt; len(nums); i++ { sum += nums[i] sum -= nums[i-k] ans = max(ans,sum) } return float64(ans)/float64(k) } func max(a,b int) int { if a &amp;gt; b { return a } return b }   复杂度分析 时间复杂度O(n),其中n是数组nums的长度。遍历数组一次。</description>
    </item>
    
    <item>
      <title>LEETCODE 480. 滑动窗口中位数</title>
      <link>https://betterfor.github.io/2021/02/480/</link>
      <pubDate>Wed, 03 Feb 2021 20:22:04 +0800</pubDate>
      
      <guid>https://betterfor.github.io/2021/02/480/</guid>
      <description>大家好，我是沉迷于刷题的小耗。
今天给大家带来的是力扣480题：滑动窗口中位数
题目 中位数是有序序列最中间的那个数。如果序列的长度是偶数，则没有最中间的数，此时中位数是最中间的两个数的平均数。
给你一个数组nums，有一个长度为k的窗口从最左端滑动到最右端。窗口中有k个数，每次窗口向右移动1位。你的任务是找出每次窗口移动后得到的新元素的中位数，并输出它们组成的数组。
示例 给出nums = [1,3,-1,-3,5,3,6,7]，以及k = 3。
窗口位置 中位数
 [1 3 -1] -3 5 3 6 7 1 1 [3 -1 -3] 5 3 6 7 -1 1 3 [-1 -3 5] 3 6 7 -1 1 3 -1 [-3 5 3] 6 7 3 1 3 -1 -3 [5 3 6] 7 5 1 3 -1 -3 5 [3 6 7] 6
题解 看到这里，停顿一下，思考一下。</description>
    </item>
    
    <item>
      <title>LEETCODE 424. 替换后的最长重复字符</title>
      <link>https://betterfor.github.io/2021/02/424/</link>
      <pubDate>Tue, 02 Feb 2021 21:31:07 +0800</pubDate>
      
      <guid>https://betterfor.github.io/2021/02/424/</guid>
      <description>大家好，我是沉迷于刷题的小耗。
今天给大家带来的是力扣424题：替换后的最长重复字符
题目 给你一个仅由大写英文字母组成的字符串，你可以将任意位置上的字符替换成另外的字符，总共可最多替换 k 次。在执行上述操作后，找到包含重复字母的最长子串的长度。
示例 示例 1:
输入: s =&amp;ldquo;ABAB&amp;rdquo;, k = 2
输出: 4
解释: 用两个&amp;quot;A&amp;quot;替换为两个&amp;quot;B&amp;quot;,反之亦然。
示例 2:
输入: s =&amp;ldquo;AABABBA&amp;rdquo;, k = 1
输出: 4
解释: 将中间的一个&amp;quot;A&amp;quot;替换为&amp;quot;B&amp;quot;,字符串变为 &amp;ldquo;AABBBBA&amp;rdquo;。 子串&amp;quot;BBBB&amp;quot;有最长重复字母, 答案为 4。
题解 1、暴力法(不实现)
思路：
 如果子串中所有的字符都一样就延伸子串 如果当前子串出现至少两种字符，就要替换使得所有的字符都一样，并且重复、连续的部分更长。  暴力解法的时间复杂度O(n^3^)。
缺点：
做了很多重复的工作，子串和子串有很多重复的部分，重复扫描了很多次。
2、优化方法
优化字符串查找子串，我们能够想到两种方法，动态规划和滑动窗口。而本题动态规划没有得到明显的递推关系，所以是要用滑动窗口。
所以题目的意思可以转化为
枚举字符串中每个位置作为右端点，然后找到其最左端点的位置，满足该区间内除了出现次数最多的那一类字符外，剩余的字符数量不超过k个。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  func characterReplacement(s string, k int) int { var left,maxCnt int	// maxCnt保存整个循环中，cnt出现的最大值  var cnt [26]int // cnt记录了s[left:right+1]中每个字母出现的次数  // 在循环中，s[left:right+1]  // 要么，maxCnt变大，向右移动一格  // 要么，maxCnt不变，向右移动一格。 	for right, str := range s { cnt[str-&amp;#39;A&amp;#39;]++ maxCnt = max(maxCnt,cnt[str-&amp;#39;A&amp;#39;]) // right-left+1-maxCnt==k的含义是在s[left:right+1]中有maxCnt个相同的字母和k个不相同的字母 	if right - left+1-maxCnt &amp;gt; k { cnt[s[left]-&amp;#39;A&amp;#39;]-- left++ } } return len(s)-left } func max(a, b int) int { if a &amp;gt; b { return a } return b }   复杂度分析 时间复杂度O(n)，n为字符串大小，我们最多遍历字符串一次</description>
    </item>
    
    <item>
      <title>LEETCODE 888. 公平的糖果交换</title>
      <link>https://betterfor.github.io/2021/02/888/</link>
      <pubDate>Mon, 01 Feb 2021 14:00:00 +0800</pubDate>
      
      <guid>https://betterfor.github.io/2021/02/888/</guid>
      <description>大家好，我是沉迷于刷题的小耗。
今天给大家带来的是力扣888题：公平的糖果棒交换
题目 爱丽丝和鲍勃有不同大小的糖果棒：A[i] 是爱丽丝拥有的第 i 块糖的大小，B[j] 是鲍勃拥有的第 j 块糖的大小。
因为他们是朋友，所以他们想交换一个糖果棒，这样交换后，他们都有相同的糖果总量。（一个人拥有的糖果总量是他们拥有的糖果棒大小的总和。）
返回一个整数数组 ans ，其中 ans[0] 是爱丽丝必须交换的糖果棒的大小，ans[1] 是 Bob 必须交换的糖果棒的大小。
如果有多个答案，你可以返回其中任何一个。保证答案存在。
示例 题解 这是一道简单题，很明显我们可以有一个思路，既然答案确定存在，那么最终两个的糖果数相等，那么记爱丽丝的糖果棒总数为 sumA,鲍勃的糖果棒总数为 sumB,记最终答案为{x,y},即爱丽丝的大小为x的糖果棒和鲍勃的大小为y的糖果棒交换，有等式
$$ sumA-x+y=sumB+x-y $$ 化简，得: $$ x=y+(sumA-sumB)/2 $$
为了快速查询A中是否存在某个数，可以先将A中的数字放入哈希表中，然后遍历B
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  func fairCandySwap(A []int, B []int) []int { var sumA,sumB int var mapA = make(map[int]struct{},len(A)) for _, a := range A { sumA += a mapA[a] = struct{}{} } for _, b := range B { sumB += b } diff := (sumA- sumB)/2 for _, b := range B { a := b+diff if _, ok := mapA[a]; ok { return []int{a,b} } } return nil }   复杂度分析 时间复杂度: O(m+n),m是A的长度,n是B的长度</description>
    </item>
    
    <item>
      <title>LEETCODE 002. 两数相加</title>
      <link>https://betterfor.github.io/2021/01/002/</link>
      <pubDate>Thu, 28 Jan 2021 16:17:54 +0800</pubDate>
      
      <guid>https://betterfor.github.io/2021/01/002/</guid>
      <description>众所周知啊，链表题是题库一个比较大的分类。那么今天我们开始解决第一道链表题。
那么什么是链表呢？
1 2 3 4  type ListNode struct { Val int Next *ListNode }   我们通常把这种结构称为链表。
那么链表有什么样的特点呢？
 顺序存储结构 插入和删除只能修改指针，不能随机存取   那么来看看今天的题~
给出两个 非空 的链表用来表示两个非负的整数。 其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。
如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。
可能看到这里会感觉到云里雾里，来看看一个示例：
这样一看是不是就很清晰明了了。
也就是说我们只要按照链表的顺序相加，如果和大于10，需要进位，所以我们需要一个数 carry 来保存进位数。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  func addTwoNumbers(l1, l2 *ListNode) *ListNode { var head = new(ListNode) current := head var carry int for l1 !</description>
    </item>
    
    <item>
      <title>LEETCODE 001. 两数之和</title>
      <link>https://betterfor.github.io/2021/01/001/</link>
      <pubDate>Thu, 28 Jan 2021 14:25:18 +0800</pubDate>
      
      <guid>https://betterfor.github.io/2021/01/001/</guid>
      <description>众所周知啊，leetcode有一道&amp;quot;神题&amp;quot;，有多神呢？来看一组数据
超过百万的提交，通过率达到一半!!!
那么这道题是哪一题呢？相信很多聪明的小伙伴已经猜出来了，就是第一题。
俗话说，万事开头难，只要肯放弃，只要肯攀登。
那么今天，我们就来看看这道题到底有多难。
 请看题
给定一个整数数组nums和一个整数目标值target， 请你在该数组中找出和为目标值的那两个整数， 并返回它们的数组下标。
咦~，看起来好像很简单，我们只要让每个数和他后面的数依次相加，比较target，就能得到结果。
话不多说，立刻来手写代码
1 2 3 4 5 6 7 8 9 10  func twoSum(nums []int,target int) []int { for i := 0; i &amp;lt; len(nums); i++ { for j := i+1; j &amp;lt; len(nums); j++ { if nums[i] + nums[j] == target { return []int{i,j} } } } return nil }   执行-&amp;gt;提交
有问题~ 属实有问题~
居然还有将近8%的用户超过了这方法， 这可是时间复杂度达到O(n^2^),空间复杂度达到O(1)的暴力法啊。
那要怎么超过其他人呢？</description>
    </item>
    
  </channel>
</rss>
