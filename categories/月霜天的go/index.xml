<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>月霜天的GO - 分类 - 月霜天的小站</title>
        <link>https://blog.betterformile.ml/categories/%E6%9C%88%E9%9C%9C%E5%A4%A9%E7%9A%84go/</link>
        <description>月霜天的GO - 分类 - 月霜天的小站</description>
        <generator>Hugo -- gohugo.io</generator><language>zh-CN</language><copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright><lastBuildDate>Mon, 19 Jul 2021 14:44:23 &#43;0800</lastBuildDate><atom:link href="https://blog.betterformile.ml/categories/%E6%9C%88%E9%9C%9C%E5%A4%A9%E7%9A%84go/" rel="self" type="application/rss+xml" /><item>
    <title>no copy机制</title>
    <link>https://blog.betterformile.ml/2021/07/nocopy%E6%9C%BA%E5%88%B6/</link>
    <pubDate>Mon, 19 Jul 2021 14:44:23 &#43;0800</pubDate>
    <author>作者</author>
    <guid>https://blog.betterformile.ml/2021/07/nocopy%E6%9C%BA%E5%88%B6/</guid>
    <description><![CDATA[在sync包下面经常出现&quot;XXX must not be copied after first use.&quot;，然后下面就有一个noCopy。 什么是noCopy ? 如果结构体对象]]></description>
</item><item>
    <title>并发编程之sync.Pool</title>
    <link>https://blog.betterformile.ml/2021/07/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8Bsync.pool/</link>
    <pubDate>Fri, 16 Jul 2021 10:53:06 &#43;0800</pubDate>
    <author>作者</author>
    <guid>https://blog.betterformile.ml/2021/07/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8Bsync.pool/</guid>
    <description><![CDATA[我们通常用golang来构建高并发场景下的应用，但是由于golang内建的GC机制会影响应用的性能，为了减少GC，golang提供了对象重用]]></description>
</item><item>
    <title>并发编程之Map</title>
    <link>https://blog.betterformile.ml/2021/07/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8Bsync.map/</link>
    <pubDate>Fri, 16 Jul 2021 10:53:02 &#43;0800</pubDate>
    <author>作者</author>
    <guid>https://blog.betterformile.ml/2021/07/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8Bsync.map/</guid>
    <description><![CDATA[golang原生的map是不支持并发，而在sync/map是线程安全的，可以并发读写，适用于读多写少的场景。 sync.Map是Go map[i]]></description>
</item><item>
    <title>并发编程之读写锁</title>
    <link>https://blog.betterformile.ml/2021/07/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E8%AF%BB%E5%86%99%E9%94%81/</link>
    <pubDate>Fri, 16 Jul 2021 10:52:34 &#43;0800</pubDate>
    <author>作者</author>
    <guid>https://blog.betterformile.ml/2021/07/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E8%AF%BB%E5%86%99%E9%94%81/</guid>
    <description><![CDATA[读写锁是基于互斥锁Mutex实现的读写互斥锁，一个goroutine可以持有多个读锁或一个写锁，同一时刻只能同时持有读锁或写锁。 RWMute]]></description>
</item><item>
    <title>并发编程之互斥锁</title>
    <link>https://blog.betterformile.ml/2021/07/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8Bsync.mutex/</link>
    <pubDate>Fri, 16 Jul 2021 10:52:20 &#43;0800</pubDate>
    <author>作者</author>
    <guid>https://blog.betterformile.ml/2021/07/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8Bsync.mutex/</guid>
    <description><![CDATA[并发必然会带来对于资源的竞争，这时需要使用go提供的sync.Mutex这把互斥锁来保证临界资源的访问互斥了。 锁的性质 在代码注释开篇就有一大]]></description>
</item><item>
    <title>并发编程之条件变量Cond</title>
    <link>https://blog.betterformile.ml/2021/07/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8Bsync.cond/</link>
    <pubDate>Fri, 16 Jul 2021 10:52:14 &#43;0800</pubDate>
    <author>作者</author>
    <guid>https://blog.betterformile.ml/2021/07/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8Bsync.cond/</guid>
    <description><![CDATA[sync.Cond字面意思就是同步条件变量，它实现的是一种监视器(Monitor)模式。 对于Cond而言，它实现一个条件变量，是gorout]]></description>
</item><item>
    <title>并发编程之WaitGroup</title>
    <link>https://blog.betterformile.ml/2021/07/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8Bsync.waitgroup/</link>
    <pubDate>Fri, 16 Jul 2021 10:52:06 &#43;0800</pubDate>
    <author>作者</author>
    <guid>https://blog.betterformile.ml/2021/07/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8Bsync.waitgroup/</guid>
    <description><![CDATA[waitgroup的使用场景： 一个waitgroup对象可以等到一组协程结束，也就是等待一组goroutine返回。 首先我们来看看sync.]]></description>
</item><item>
    <title>并发编程之sync.Once</title>
    <link>https://blog.betterformile.ml/2021/07/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8Bsync.once%E7%9A%84%E5%AE%9E%E7%8E%B0/</link>
    <pubDate>Fri, 16 Jul 2021 10:50:32 &#43;0800</pubDate>
    <author>作者</author>
    <guid>https://blog.betterformile.ml/2021/07/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8Bsync.once%E7%9A%84%E5%AE%9E%E7%8E%B0/</guid>
    <description><![CDATA[Go语言标准库中的sync.Once可以保证go程序在运行期间的某段代码只执行一次。 而我们来看看sync.Once的源码，发现是比较少的。 去]]></description>
</item><item>
    <title>深入理解channel</title>
    <link>https://blog.betterformile.ml/2021/07/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3channel/</link>
    <pubDate>Thu, 15 Jul 2021 15:00:10 &#43;0800</pubDate>
    <author>作者</author>
    <guid>https://blog.betterformile.ml/2021/07/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3channel/</guid>
    <description><![CDATA[channel设计的基本思想是： 不要通过共享内存来通信，而是要通过通信来实现共享内存。 Do not communicate by sharing memory; instead, share memory by communicating. channel在设计上本质就是一]]></description>
</item><item>
    <title>深入理解Golang Map</title>
    <link>https://blog.betterformile.ml/2021/07/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3map/</link>
    <pubDate>Wed, 14 Jul 2021 09:34:50 &#43;0800</pubDate>
    <author>作者</author>
    <guid>https://blog.betterformile.ml/2021/07/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3map/</guid>
    <description><![CDATA[前言 Map是一种常用的数据结构，通常用于存储无序的键值对。但是，Map在Golang中是如何实现的？ 如果判断Map中是否包含某个key？ Ma]]></description>
</item></channel>
</rss>
