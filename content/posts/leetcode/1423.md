---
title: "LEETCODE 1423. 可获得的最大点数"
date: 2021-02-06T20:52:42+08:00
description: 算法题解
draft: false

tags: ["中等","滑动窗口"]
categories: ['leetcode']
comment: true
toc: true
autoCollapseToc: false
---

大家好，我是沉迷于刷题的小耗。

今天给大家带来的是力扣1423题：**可获得的最大点数**

## 题目

几张卡牌**排成一行**，每张卡牌都有一个点数。点数由整数数组`cardPoints`给出。

每次行动，你可以从行的开头或结尾拿一张卡牌，最终你必须正好拿`k`张卡牌。

你的点数就是你拿到手中所有卡牌点数之和。

给你一个整数数组`cardPoints`和整数`k`，请你返回可以获得的最大点数。

## 示例

**输入：**cardPoints = [1,2,3,4,5,6,1], k = 3
**输出：**12
**解释：**第一次行动，不管拿哪张牌，你的点数总是 1 。但是，先拿最右边的卡牌将会最大化你的可获得点数。最优策略是拿右边的三张牌，最终点数为 1 + 6 + 5 = 12 。

## 题解

### 滑动窗口

如果从左边拿走`i`个，那么从右边会拿走`k-i`个，这样`i`从`0`到`k`的最大值就是所求的最大点数。

`i=0`时，左0，右k。

`i=1`时，左1，右k-1。

你会发现，有部分值会重复累加，那么我们先把这部分重复累加的值先求出来。

`left`是从左向右的累加序列，`right`是从右向左的累加序列。

```go 
func maxScore(cardPoints []int, k int) (ans int) {
	n := len(cardPoints)
	var left, right = make([]int, k), make([]int, k)
	left[0], right[0] = cardPoints[0], cardPoints[n-1]
	for i := 1; i < k; i++ {
		left[i] = left[i-1] + cardPoints[i]
		right[i] = right[i-1] + cardPoints[n-i-1]
	}
	left, right = append([]int{0}, left...), append([]int{0}, right...)
	for i := 0; i < k+1; i++ {
		ans = max(ans, left[i]+right[k-i])
	}
	return ans
}

func max(a, b int) int {
	if a > b {
		return a
	}
	return b
}
```

时间复杂度O(n),空间复杂度O(n)

### 优化滑动窗口

我们会发现，如果每次都取左边或右边的值，那么最终剩下的是一个连续的中间序列，此问题就能转化为求一个连续序列，长度为`n-k`之和的最小值。

```go
func maxScore(cardPoints []int, k int) int {
    n := len(cardPoints)
    windows := n-k
    var sum,total int
    for i,point := range cardPoints {
        if i < windows {
            sum += point
        }
        total += point
    }
    ans := sum
    for i := windows; i < n; i++ {
        sum += cardPoints[i]-cardPoints[i-windows]
        ans = min(ans,sum)
    }
    return total-ans
}

func min(a,b int) int {
    if a < b {
        return a
    }
    return b
}
```

时间复杂度O(n),空间复杂度O(1)