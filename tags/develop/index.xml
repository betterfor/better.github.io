<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>develop on 风落云起</title>
    <link>https://betterfor.github.io/tags/develop/</link>
    <description>Recent content in develop on 风落云起</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh</language>
    <copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright>
    <lastBuildDate>Mon, 11 Jan 2021 15:17:18 +0800</lastBuildDate><atom:link href="https://betterfor.github.io/tags/develop/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>并查集</title>
      <link>https://betterfor.github.io/2021/01/%E5%B9%B6%E6%9F%A5%E9%9B%86/</link>
      <pubDate>Mon, 11 Jan 2021 15:17:18 +0800</pubDate>
      
      <guid>https://betterfor.github.io/2021/01/%E5%B9%B6%E6%9F%A5%E9%9B%86/</guid>
      <description>并查集 目的: 解决元素分组问题
用途: 1、判断有向图中是否产生环 2、维护无向图的连通性，判断两个点是否在同一个连通块中
操作: 1、初始化: 每个集合的parent都是自己 2、查询: 查询集合的parent 3、合并: 把不相连的元素合并到同一个集合中
方法 1、初始化 假如有编号为1, 2, 3, &amp;hellip;, n的n个元素，我们用一个数组fa[]来存储每个元素的父节点（因为每个元素有且只有一个父节点，所以这是可行的）。 一开始，我们先将它们的父节点设为自己。
1 2 3 4  var fa = make([]int,n) for i := 0; i &amp;lt; n; i++ { fa[i] = i }   2、查询 我们用递归的写法实现对代表元素的查询：一层一层访问父节点，直至根节点（根节点的标志就是父节点是本身）。 要判断两个元素是否属于同一个集合，只需要看它们的根节点是否相同即可。
1 2 3 4 5 6  find = func(x int) int { if x == fa[x] { return x } return find(fa[x]) }   路径压缩方法</description>
    </item>
    
  </channel>
</rss>
