<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>双指针 on 风落云起</title>
    <link>https://betterfor.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88/</link>
    <description>Recent content in 双指针 on 风落云起</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh</language>
    <copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright>
    <lastBuildDate>Tue, 02 Feb 2021 21:31:07 +0800</lastBuildDate><atom:link href="https://betterfor.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>LEETCODE 424. 替换后的最长重复字符</title>
      <link>https://betterfor.github.io/2021/02/424/</link>
      <pubDate>Tue, 02 Feb 2021 21:31:07 +0800</pubDate>
      
      <guid>https://betterfor.github.io/2021/02/424/</guid>
      <description>大家好，我是沉迷于刷题的小耗。
今天给大家带来的是力扣424题：替换后的最长重复字符
题目 给你一个仅由大写英文字母组成的字符串，你可以将任意位置上的字符替换成另外的字符，总共可最多替换 k 次。在执行上述操作后，找到包含重复字母的最长子串的长度。
示例 示例 1:
输入: s =&amp;ldquo;ABAB&amp;rdquo;, k = 2
输出: 4
解释: 用两个&amp;quot;A&amp;quot;替换为两个&amp;quot;B&amp;quot;,反之亦然。
示例 2:
输入: s =&amp;ldquo;AABABBA&amp;rdquo;, k = 1
输出: 4
解释: 将中间的一个&amp;quot;A&amp;quot;替换为&amp;quot;B&amp;quot;,字符串变为 &amp;ldquo;AABBBBA&amp;rdquo;。 子串&amp;quot;BBBB&amp;quot;有最长重复字母, 答案为 4。
题解 1、暴力法(不实现)
思路：
 如果子串中所有的字符都一样就延伸子串 如果当前子串出现至少两种字符，就要替换使得所有的字符都一样，并且重复、连续的部分更长。  暴力解法的时间复杂度O(n^3^)。
缺点：
做了很多重复的工作，子串和子串有很多重复的部分，重复扫描了很多次。
2、优化方法
优化字符串查找子串，我们能够想到两种方法，动态规划和滑动窗口。而本题动态规划没有得到明显的递推关系，所以是要用滑动窗口。
所以题目的意思可以转化为
枚举字符串中每个位置作为右端点，然后找到其最左端点的位置，满足该区间内除了出现次数最多的那一类字符外，剩余的字符数量不超过k个。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  func characterReplacement(s string, k int) int { var left,maxCnt int	// maxCnt保存整个循环中，cnt出现的最大值  var cnt [26]int // cnt记录了s[left:right+1]中每个字母出现的次数  // 在循环中，s[left:right+1]  // 要么，maxCnt变大，向右移动一格  // 要么，maxCnt不变，向右移动一格。 	for right, str := range s { cnt[str-&amp;#39;A&amp;#39;]++ maxCnt = max(maxCnt,cnt[str-&amp;#39;A&amp;#39;]) // right-left+1-maxCnt==k的含义是在s[left:right+1]中有maxCnt个相同的字母和k个不相同的字母 	if right - left+1-maxCnt &amp;gt; k { cnt[s[left]-&amp;#39;A&amp;#39;]-- left++ } } return len(s)-left } func max(a, b int) int { if a &amp;gt; b { return a } return b }   复杂度分析 时间复杂度O(n)，n为字符串大小，我们最多遍历字符串一次</description>
    </item>
    
  </channel>
</rss>
