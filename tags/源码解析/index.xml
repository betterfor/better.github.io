<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>源码解析 - 标签 - 月霜天的小站</title>
        <link>https://blog.betterformile.ml/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</link>
        <description>源码解析 - 标签 - 月霜天的小站</description>
        <generator>Hugo -- gohugo.io</generator><language>zh-CN</language><copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright><lastBuildDate>Fri, 16 Jul 2021 10:53:06 &#43;0800</lastBuildDate><atom:link href="https://blog.betterformile.ml/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/" rel="self" type="application/rss+xml" /><item>
    <title>并发编程之sync.Pool</title>
    <link>https://blog.betterformile.ml/2021/07/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8Bsync.pool/</link>
    <pubDate>Fri, 16 Jul 2021 10:53:06 &#43;0800</pubDate>
    <author>作者</author>
    <guid>https://blog.betterformile.ml/2021/07/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8Bsync.pool/</guid>
    <description><![CDATA[我们通常用golang来构建高并发场景下的应用，但是由于golang内建的GC机制会影响应用的性能，为了减少GC，golang提供了对象重用]]></description>
</item><item>
    <title>并发编程之Map</title>
    <link>https://blog.betterformile.ml/2021/07/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8Bsync.map/</link>
    <pubDate>Fri, 16 Jul 2021 10:53:02 &#43;0800</pubDate>
    <author>作者</author>
    <guid>https://blog.betterformile.ml/2021/07/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8Bsync.map/</guid>
    <description><![CDATA[golang原生的map是不支持并发，而在sync/map是线程安全的，可以并发读写，适用于读多写少的场景。 sync.Map是Go map[i]]></description>
</item><item>
    <title>并发编程之读写锁</title>
    <link>https://blog.betterformile.ml/2021/07/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E8%AF%BB%E5%86%99%E9%94%81/</link>
    <pubDate>Fri, 16 Jul 2021 10:52:34 &#43;0800</pubDate>
    <author>作者</author>
    <guid>https://blog.betterformile.ml/2021/07/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E8%AF%BB%E5%86%99%E9%94%81/</guid>
    <description><![CDATA[读写锁是基于互斥锁Mutex实现的读写互斥锁，一个goroutine可以持有多个读锁或一个写锁，同一时刻只能同时持有读锁或写锁。 RWMute]]></description>
</item><item>
    <title>并发编程之互斥锁</title>
    <link>https://blog.betterformile.ml/2021/07/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8Bsync.mutex/</link>
    <pubDate>Fri, 16 Jul 2021 10:52:20 &#43;0800</pubDate>
    <author>作者</author>
    <guid>https://blog.betterformile.ml/2021/07/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8Bsync.mutex/</guid>
    <description><![CDATA[并发必然会带来对于资源的竞争，这时需要使用go提供的sync.Mutex这把互斥锁来保证临界资源的访问互斥了。 锁的性质 在代码注释开篇就有一大]]></description>
</item><item>
    <title>并发编程之条件变量Cond</title>
    <link>https://blog.betterformile.ml/2021/07/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8Bsync.cond/</link>
    <pubDate>Fri, 16 Jul 2021 10:52:14 &#43;0800</pubDate>
    <author>作者</author>
    <guid>https://blog.betterformile.ml/2021/07/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8Bsync.cond/</guid>
    <description><![CDATA[sync.Cond字面意思就是同步条件变量，它实现的是一种监视器(Monitor)模式。 对于Cond而言，它实现一个条件变量，是gorout]]></description>
</item><item>
    <title>并发编程之WaitGroup</title>
    <link>https://blog.betterformile.ml/2021/07/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8Bsync.waitgroup/</link>
    <pubDate>Fri, 16 Jul 2021 10:52:06 &#43;0800</pubDate>
    <author>作者</author>
    <guid>https://blog.betterformile.ml/2021/07/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8Bsync.waitgroup/</guid>
    <description><![CDATA[waitgroup的使用场景： 一个waitgroup对象可以等到一组协程结束，也就是等待一组goroutine返回。 首先我们来看看sync.]]></description>
</item><item>
    <title>并发编程之sync.Once</title>
    <link>https://blog.betterformile.ml/2021/07/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8Bsync.once%E7%9A%84%E5%AE%9E%E7%8E%B0/</link>
    <pubDate>Fri, 16 Jul 2021 10:50:32 &#43;0800</pubDate>
    <author>作者</author>
    <guid>https://blog.betterformile.ml/2021/07/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8Bsync.once%E7%9A%84%E5%AE%9E%E7%8E%B0/</guid>
    <description><![CDATA[Go语言标准库中的sync.Once可以保证go程序在运行期间的某段代码只执行一次。 而我们来看看sync.Once的源码，发现是比较少的。 去]]></description>
</item><item>
    <title>深入理解channel</title>
    <link>https://blog.betterformile.ml/2021/07/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3channel/</link>
    <pubDate>Thu, 15 Jul 2021 15:00:10 &#43;0800</pubDate>
    <author>作者</author>
    <guid>https://blog.betterformile.ml/2021/07/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3channel/</guid>
    <description><![CDATA[channel设计的基本思想是： 不要通过共享内存来通信，而是要通过通信来实现共享内存。 Do not communicate by sharing memory; instead, share memory by communicating. channel在设计上本质就是一]]></description>
</item><item>
    <title>Go定时器源码分析</title>
    <link>https://blog.betterformile.ml/2021/07/go%E5%AE%9A%E6%97%B6%E5%99%A8%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</link>
    <pubDate>Thu, 01 Jul 2021 15:44:20 &#43;0800</pubDate>
    <author>作者</author>
    <guid>https://blog.betterformile.ml/2021/07/go%E5%AE%9A%E6%97%B6%E5%99%A8%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</guid>
    <description><![CDATA[虽然golang的定时器经过几版的改进优化，但是仍然是性能的大杀手。 golang1.13和1.14的区别 golang在1.10版本之前是由一]]></description>
</item><item>
    <title>并发编程之原子操作</title>
    <link>https://blog.betterformile.ml/2021/06/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C/</link>
    <pubDate>Thu, 03 Jun 2021 09:59:51 &#43;0800</pubDate>
    <author>作者</author>
    <guid>https://blog.betterformile.ml/2021/06/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C/</guid>
    <description><![CDATA[原子操作 我们先给原子操作下一个定义： 原子(atom)：在化学反应中不可再分的基本微粒。 原子操作(atomic operation)：不会被线程]]></description>
</item></channel>
</rss>
