<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>简单 on 风落云起</title>
    <link>https://betterfor.github.io/tags/%E7%AE%80%E5%8D%95/</link>
    <description>Recent content in 简单 on 风落云起</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh</language>
    <copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright>
    <lastBuildDate>Mon, 01 Feb 2021 14:00:00 +0800</lastBuildDate><atom:link href="https://betterfor.github.io/tags/%E7%AE%80%E5%8D%95/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>LEETCODE 888. 公平的糖果交换</title>
      <link>https://betterfor.github.io/2021/02/888/</link>
      <pubDate>Mon, 01 Feb 2021 14:00:00 +0800</pubDate>
      
      <guid>https://betterfor.github.io/2021/02/888/</guid>
      <description>大家好，我是沉迷于刷题的小耗。
今天给大家带来的是力扣888题：公平的糖果棒交换
题目 爱丽丝和鲍勃有不同大小的糖果棒：A[i] 是爱丽丝拥有的第 i 块糖的大小，B[j] 是鲍勃拥有的第 j 块糖的大小。
因为他们是朋友，所以他们想交换一个糖果棒，这样交换后，他们都有相同的糖果总量。（一个人拥有的糖果总量是他们拥有的糖果棒大小的总和。）
返回一个整数数组 ans ，其中 ans[0] 是爱丽丝必须交换的糖果棒的大小，ans[1] 是 Bob 必须交换的糖果棒的大小。
如果有多个答案，你可以返回其中任何一个。保证答案存在。
示例 题解 这是一道简单题，很明显我们可以有一个思路，既然答案确定存在，那么最终两个的糖果数相等，那么记爱丽丝的糖果棒总数为 sumA,鲍勃的糖果棒总数为 sumB,记最终答案为{x,y},即爱丽丝的大小为x的糖果棒和鲍勃的大小为y的糖果棒交换，有等式
$$ sumA-x+y=sumB+x-y $$ 化简，得: $$ x=y+(sumA-sumB)/2 $$
为了快速查询A中是否存在某个数，可以先将A中的数字放入哈希表中，然后遍历B
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  func fairCandySwap(A []int, B []int) []int { var sumA,sumB int var mapA = make(map[int]struct{},len(A)) for _, a := range A { sumA += a mapA[a] = struct{}{} } for _, b := range B { sumB += b } diff := (sumA- sumB)/2 for _, b := range B { a := b+diff if _, ok := mapA[a]; ok { return []int{a,b} } } return nil }   复杂度分析 时间复杂度: O(m+n),m是A的长度,n是B的长度</description>
    </item>
    
    <item>
      <title>LEETCODE 001. 两数之和</title>
      <link>https://betterfor.github.io/2021/01/001/</link>
      <pubDate>Thu, 28 Jan 2021 14:25:18 +0800</pubDate>
      
      <guid>https://betterfor.github.io/2021/01/001/</guid>
      <description>众所周知啊，leetcode有一道&amp;quot;神题&amp;quot;，有多神呢？来看一组数据
超过百万的提交，通过率达到一半!!!
那么这道题是哪一题呢？相信很多聪明的小伙伴已经猜出来了，就是第一题。
俗话说，万事开头难，只要肯放弃，只要肯攀登。
那么今天，我们就来看看这道题到底有多难。
 请看题
给定一个整数数组nums和一个整数目标值target， 请你在该数组中找出和为目标值的那两个整数， 并返回它们的数组下标。
咦~，看起来好像很简单，我们只要让每个数和他后面的数依次相加，比较target，就能得到结果。
话不多说，立刻来手写代码
1 2 3 4 5 6 7 8 9 10  func twoSum(nums []int,target int) []int { for i := 0; i &amp;lt; len(nums); i++ { for j := i+1; j &amp;lt; len(nums); j++ { if nums[i] + nums[j] == target { return []int{i,j} } } } return nil }   执行-&amp;gt;提交
有问题~ 属实有问题~
居然还有将近8%的用户超过了这方法， 这可是时间复杂度达到O(n^2^),空间复杂度达到O(1)的暴力法啊。
那要怎么超过其他人呢？</description>
    </item>
    
  </channel>
</rss>
